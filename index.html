<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–ì–æ–Ω–∫–∏ —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º</title>
    <style>
        :root {
            --primary-color: #e74c3c;
            --road-color: #7f8c8d;
            --bg-color: #2c3e50;
            --text-color: #ecf0f1;
            --button-bg: #3498db;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: var(--bg-color);
            color: var(--text-color);
            touch-action: pan-x pan-y;
            min-height: 100dvh;
            font-family: Arial, sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            flex-grow: 1;
            max-width: 600px;
        }

        #gameCanvas {
            display: block;
            background: var(--road-color);
            touch-action: none;
            width: 100%;
            height: 70vh;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            padding: 1rem;
            width: 100%;
            max-width: 600px;
            box-sizing: border-box;
        }

        .control-btn {
            padding: 1rem;
            font-size: 1.5rem;
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            background: var(--button-bg);
            color: white;
            transition: transform 0.1s;
            touch-action: manipulation;
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .score-board {
            display: flex;
            gap: 2rem;
            padding: 1rem;
            font-size: 1.2rem;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            display: none;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0,0,0,0);
            border: 0;
        }
    </style>
</head>
<body>
    <header role="banner">
        <div class="score-board">
            <div>–°—á—ë—Ç: <span id="currentScore">0</span></div>
            <div>–†–µ–∫–æ—Ä–¥: <span id="bestScore">0</span></div>
        </div>
    </header>

    <main id="gameContainer" role="main">
        <canvas id="gameCanvas" aria-label="–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ —Å –¥–≤–∏–∂—É—â–µ–π—Å—è –º–∞—à–∏–Ω–∫–æ–π">
            <p>–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç Canvas. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ –±—Ä–∞—É–∑–µ—Ä.</p>
        </canvas>
        
        <div class="game-over" id="gameOver" role="alert">
            <h2>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!</h2>
            <button class="control-btn" onclick="restartGame()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
        </div>
    </main>

    <footer role="contentinfo">
        <div class="controls">
            <button 
                id="leftBtn" 
                class="control-btn"
                aria-label="–î–≤–∏–∂–µ–Ω–∏–µ –≤–ª–µ–≤–æ"
                onpointerdown="startMove(-1)"
                onpointerup="stopMove()"
                onpointercancel="stopMove()">
                ‚Üê
            </button>
            
            <button 
                id="soundBtn" 
                class="control-btn"
                aria-label="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫"
                onclick="toggleSound()">
                <span aria-hidden="true">üîä</span>
                <span class="sr-only">–ó–≤—É–∫:</span>
                <span id="soundState">–í–∫–ª</span>
            </button>
            
            <button 
                id="rightBtn" 
                class="control-btn"
                aria-label="–î–≤–∏–∂–µ–Ω–∏–µ –≤–ø—Ä–∞–≤–æ"
                onpointerdown="startMove(1)"
                onpointerup="stopMove()"
                onpointercancel="stopMove()">
                ‚Üí
            </button>
        </div>
    </footer>

    <script>
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let enemies = [];
        let score = 0;
        let bestScore = localStorage.getItem('bestScore') || 0;
        let isGameOver = false;
        let soundEnabled = true;
        let lastTime = 0;
        let animationFrameId;
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        let moveDirection = 0;
        let isMoving = false;

        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        const CONFIG = {
            ROAD: {
                widthRatio: 0.8,
                lanes: 4,
                dash: [50, 30]
            },
            PLAYER: {
                maxSpeed: 12,
                acceleration: 0.6,
                friction: 0.1,
                width: 40,
                height: 60
            },
            ENEMY: {
                spawnRate: 1500,
                minSpeed: 3,
                maxSpeed: 6
            }
        };

        // –ò–≥—Ä–æ–∫
        const player = {
            x: 0,
            y: 0,
            lane: 1,
            speed: 0,
            targetLane: 1,
            updatePosition(deltaTime) {
                const targetX = getLaneCenter(this.targetLane) - CONFIG.PLAYER.width/2;
                const dx = targetX - this.x;
                
                if(Math.abs(dx) > 1) {
                    this.speed += CONFIG.PLAYER.acceleration * Math.sign(dx) * (deltaTime/16);
                    this.speed = Math.max(-CONFIG.PLAYER.maxSpeed, 
                                      Math.min(CONFIG.PLAYER.maxSpeed, this.speed));
                } else {
                    this.speed *= (1 - CONFIG.PLAYER.friction);
                }
                
                this.x += this.speed * (deltaTime/16);
                this.x = Math.max(getLaneCenter(0) - CONFIG.PLAYER.width/2, 
                               Math.min(getLaneCenter(3) - CONFIG.PLAYER.width/2, this.x));
                this.y = canvas.height - CONFIG.PLAYER.height * 1.5;
            }
        };

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        window.startMove = function(direction) {
            if (isGameOver) return;
            moveDirection = direction;
            isMoving = true;
        };

        window.stopMove = function() {
            isMoving = false;
            moveDirection = 0;
        };

        function updateControl() {
            if (!isMoving) return;
            
            const newLane = player.targetLane + moveDirection;
            player.targetLane = Math.max(0, Math.min(3, newLane));
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        function init() {
            resizeCanvas();
            player.updatePosition(0);
            window.addEventListener('resize', resizeCanvas);
            document.getElementById('bestScore').textContent = Math.floor(bestScore/100);
            startGame();
        }

        function startGame() {
            isGameOver = false;
            score = 0;
            enemies = [];
            player.lane = 1;
            player.targetLane = 1;
            lastTime = 0;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight * 0.7;
            CONFIG.PLAYER.width = canvas.width * 0.07;
            CONFIG.PLAYER.height = canvas.width * 0.12;
        }

        function drawRoad() {
            ctx.fillStyle = '#7f8c8d';
            const roadWidth = canvas.width * CONFIG.ROAD.widthRatio;
            const roadLeft = (canvas.width - roadWidth) / 2;
            ctx.fillRect(roadLeft, 0, roadWidth, canvas.height);

            ctx.strokeStyle = '#ffffff';
            ctx.setLineDash(CONFIG.ROAD.dash);
            ctx.lineWidth = 4;
            
            for(let i = 1; i < CONFIG.ROAD.lanes; i++) {
                const x = roadLeft + (roadWidth / CONFIG.ROAD.lanes) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            updateControl();
            player.updatePosition(deltaTime);
            
            if (!isGameOver) {
                updateGame(deltaTime);
                draw();
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function updateGame(deltaTime) {
            enemies.forEach(enemy => {
                enemy.y += enemy.speed * (deltaTime/16);
            });

            if (Math.random() < deltaTime / CONFIG.ENEMY.spawnRate) {
                enemies.push({
                    lane: Math.floor(Math.random() * 4),
                    x: getLaneCenter(Math.floor(Math.random() * 4)) - CONFIG.PLAYER.width/2,
                    y: -CONFIG.PLAYER.height,
                    speed: CONFIG.ENEMY.minSpeed + Math.random() * (CONFIG.ENEMY.maxSpeed - CONFIG.ENEMY.minSpeed)
                });
            }

            if (checkCollision()) gameOver();

            score += deltaTime / 16;
            document.getElementById('currentScore').textContent = Math.floor(score/100);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawRoad();

            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(player.x, player.y, CONFIG.PLAYER.width, CONFIG.PLAYER.height);

            ctx.fillStyle = '#2ecc71';
            enemies.forEach(enemy => {
                ctx.fillRect(enemy.x, enemy.y, CONFIG.PLAYER.width, CONFIG.PLAYER.height);
            });
        }

        function checkCollision() {
            const playerRect = {
                x: player.x,
                y: player.y,
                width: CONFIG.PLAYER.width,
                height: CONFIG.PLAYER.height
            };

            return enemies.some(enemy => {
                const enemyRect = {
                    x: enemy.x,
                    y: enemy.y,
                    width: CONFIG.PLAYER.width,
                    height: CONFIG.PLAYER.height
                };

                return !(playerRect.x > enemyRect.x + enemyRect.width ||
                       playerRect.x + playerRect.width < enemyRect.x ||
                       playerRect.y > enemyRect.y + enemyRect.height ||
                       playerRect.y + playerRect.height < enemyRect.y);
            });
        }

        function gameOver() {
            isGameOver = true;
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('bestScore', bestScore);
                document.getElementById('bestScore').textContent = Math.floor(bestScore/100);
            }
            document.getElementById('gameOver').style.display = 'block';
            if (navigator.vibrate) navigator.vibrate(200);
            cancelAnimationFrame(animationFrameId);
        }

        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            startGame();
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundState').textContent = soundEnabled ? '–í–∫–ª' : '–í—ã–∫–ª';
        }

        function getLaneCenter(lane) {
            const roadWidth = canvas.width * CONFIG.ROAD.widthRatio;
            const laneWidth = roadWidth / CONFIG.ROAD.lanes;
            return (canvas.width - roadWidth)/2 + laneWidth * (lane + 0.5);
        }

        window.addEventListener('DOMContentLoaded', init);
        document.addEventListener('touchstart', e => e.touches.length > 1 && e.preventDefault(), { passive: false });
        document.addEventListener('gesturestart', e => e.preventDefault());
    </script>
</body>
</html>
