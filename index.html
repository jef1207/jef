<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>–ì–æ–Ω–∫–∏: –ú–∞—à–∏–Ω–∫–∞ –Ω–∞ –¥–æ—Ä–æ–≥–µ</title>
    <style>
        :root {
            --primary-color: #e74c3c;
            --road-color: #7f8c8d;
            --bg-color: #2c3e50;
            --text-color: #ecf0f1;
            --button-bg: #3498db;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: var(--bg-color);
            color: var(--text-color);
            touch-action: manipulation;
            min-height: 100dvh;
            font-family: 'Arial', sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            flex-grow: 1;
            max-width: 600px;
        }

        #gameCanvas {
            display: block;
            background: var(--road-color);
            touch-action: none;
            width: 100%;
            height: 70vh;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            padding: 1rem;
            width: 100%;
            max-width: 600px;
            box-sizing: border-box;
        }

        .control-btn {
            padding: 1rem;
            font-size: 1.5rem;
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            background: var(--button-bg);
            color: white;
            touch-action: manipulation;
            transition: transform 0.1s, opacity 0.3s;
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .score-board {
            display: flex;
            gap: 2rem;
            padding: 1rem;
            font-size: 1.2rem;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            display: none;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0,0,0,0);
            border: 0;
        }
    </style>
</head>
<body>
    <header role="banner">
        <div class="score-board">
            <div>–°—á—ë—Ç: <span id="currentScore" aria-live="polite">0</span></div>
            <div>–†–µ–∫–æ—Ä–¥: <span id="bestScore" aria-live="polite">0</span></div>
        </div>
    </header>

    <main id="gameContainer" role="main">
        <canvas id="gameCanvas" aria-label="–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ —Å –¥–≤–∏–∂—É—â–µ–π—Å—è –º–∞—à–∏–Ω–∫–æ–π">
            <p>–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç Canvas. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ –±—Ä–∞—É–∑–µ—Ä.</p>
        </canvas>
        
        <div class="game-over" id="gameOver" role="alert">
            <h2>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!</h2>
            <button class="control-btn" onclick="restartGame()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
        </div>
    </main>

    <footer role="contentinfo">
        <div class="controls">
            <button 
                id="leftBtn" 
                class="control-btn"
                aria-label="–î–≤–∏–∂–µ–Ω–∏–µ –≤–ª–µ–≤–æ"
                onpointerdown="move(-1)">
                ‚Üê
            </button>
            
            <button 
                id="soundBtn" 
                class="control-btn"
                aria-label="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫"
                onclick="toggleSound()">
                <span aria-hidden="true">üîä</span>
                <span class="sr-only">–ó–≤—É–∫:</span>
                <span id="soundState">–í–∫–ª</span>
            </button>
            
            <button 
                id="rightBtn" 
                class="control-btn"
                aria-label="–î–≤–∏–∂–µ–Ω–∏–µ –≤–ø—Ä–∞–≤–æ"
                onpointerdown="move(1)">
                ‚Üí
            </button>
        </div>
    </footer>

    <script>
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let enemies = [];
        let score = 0;
        let bestScore = localStorage.getItem('bestScore') || 0;
        let isGameOver = false;
        let soundEnabled = true;
        let lastTime = 0;
        let spawnCounter = 0;
        let animationFrameId;

        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        const CONFIG = {
            ROAD: {
                widthRatio: 0.8,
                lanes: 4,
                dash: [50, 30]
            },
            PLAYER: {
                speed: 0.2,
                width: 40,
                height: 60
            },
            ENEMY: {
                spawnRate: 2000,
                speed: 3
            }
        };

        // –ò–≥—Ä–æ–∫
        const player = {
            x: 0,
            y: 0,
            lane: 1,
            targetX: 0,
            updatePosition() {
                this.targetX = getLaneCenter(this.lane) - CONFIG.PLAYER.width/2;
                this.x += (this.targetX - this.x) * 0.1;
                this.y = canvas.height - CONFIG.PLAYER.height * 2;
            }
        };

        // –ó–≤—É–∫–æ–≤—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã (–∑–∞–≥–ª—É—à–∫–∏)
        const audio = {
            crash: { play: () => {} },
            engine: { play: () => {}, muted: false }
        };

        function init() {
            resizeCanvas();
            player.updatePosition();
            window.addEventListener('resize', resizeCanvas);
            document.getElementById('bestScore').textContent = Math.floor(bestScore/100);
            toggleSound();
            startGame();
        }

        function startGame() {
            isGameOver = false;
            score = 0;
            enemies = [];
            player.lane = 1;
            lastTime = 0;
            spawnCounter = 0;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight * 0.7;
            CONFIG.PLAYER.width = canvas.width * 0.07;
            CONFIG.PLAYER.height = canvas.width * 0.12;
        }

        function drawRoad() {
            ctx.fillStyle = '#7f8c8d';
            const roadWidth = canvas.width * CONFIG.ROAD.widthRatio;
            const roadLeft = (canvas.width - roadWidth) / 2;
            ctx.fillRect(roadLeft, 0, roadWidth, canvas.height);

            ctx.strokeStyle = '#ffffff';
            ctx.setLineDash(CONFIG.ROAD.dash);
            ctx.lineWidth = 4;
            
            for(let i = 1; i < CONFIG.ROAD.lanes; i++) {
                const x = roadLeft + (roadWidth / CONFIG.ROAD.lanes) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        function update(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            if (isGameOver) return;

            enemies.forEach(enemy => {
                enemy.y += CONFIG.ENEMY.speed * deltaTime / 16;
            });

            spawnCounter += deltaTime;
            if (spawnCounter >= CONFIG.ENEMY.spawnRate) {
                spawnEnemy();
                spawnCounter = 0;
            }

            if (checkCollision()) {
                gameOver();
                return;
            }

            score += deltaTime / 16;
            document.getElementById('currentScore').textContent = Math.floor(score/100);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawRoad();

            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(player.x, player.y, CONFIG.PLAYER.width, CONFIG.PLAYER.height);

            ctx.fillStyle = '#2ecc71';
            enemies.forEach(enemy => {
                const x = getLaneCenter(enemy.lane) - CONFIG.PLAYER.width/2;
                ctx.fillRect(x, enemy.y, CONFIG.PLAYER.width, CONFIG.PLAYER.height);
            });
        }

        function gameLoop(timestamp) {
            player.updatePosition();
            update(timestamp);
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        window.move = function(direction) {
            if (isGameOver) return;
            player.lane = Math.max(0, Math.min(3, player.lane + direction));
        };

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundState').textContent = soundEnabled ? '–í–∫–ª' : '–í—ã–∫–ª';
            Object.values(audio).forEach(sound => sound.muted = !soundEnabled);
        }

        function checkCollision() {
            const playerRect = {
                x: player.x,
                y: player.y,
                width: CONFIG.PLAYER.width,
                height: CONFIG.PLAYER.height
            };

            return enemies.some(enemy => {
                const enemyRect = {
                    x: getLaneCenter(enemy.lane) - CONFIG.PLAYER.width/2,
                    y: enemy.y,
                    width: CONFIG.PLAYER.width,
                    height: CONFIG.PLAYER.height
                };

                return !(playerRect.x > enemyRect.x + enemyRect.width ||
                       playerRect.x + playerRect.width < enemyRect.x ||
                       playerRect.y > enemyRect.y + enemyRect.height ||
                       playerRect.y + playerRect.height < enemyRect.y);
            });
        }

        function gameOver() {
            isGameOver = true;
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('bestScore', bestScore);
                document.getElementById('bestScore').textContent = Math.floor(bestScore/100);
            }
            document.getElementById('gameOver').style.display = 'block';
            if (navigator.vibrate) navigator.vibrate(200);
            if (soundEnabled) audio.crash.play();
            cancelAnimationFrame(animationFrameId);
        }

        function restartGame() {
            isGameOver = false;
            score = 0;
            enemies = [];
            player.lane = 1;
            document.getElementById('gameOver').style.display = 'none';
            startGame();
        }

        function getLaneCenter(lane) {
            const roadWidth = canvas.width * CONFIG.ROAD.widthRatio;
            const laneWidth = roadWidth / CONFIG.ROAD.lanes;
            return (canvas.width - roadWidth)/2 + laneWidth * (lane + 0.5);
        }

        function spawnEnemy() {
            enemies.push({
                lane: Math.floor(Math.random() * 4),
                y: -CONFIG.PLAYER.height,
                speed: CONFIG.ENEMY.speed
            });
        }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
