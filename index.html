<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lane Racer Pro</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            background: #2c3e50; 
            touch-action: manipulation; 
            overflow: hidden;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #gameCanvas { 
            background: #34495e; 
            border-radius: 10px; 
            margin: 10px; 
            touch-action: none; 
        }
        .controls { 
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            gap: 10px; 
            padding: 10px; 
            width: 100%; 
            max-width: 400px; 
        }
        button { 
            padding: 15px; 
            font-size: 18px; 
            border: none; 
            border-radius: 8px; 
            background: #3498db; 
            color: white; 
            touch-action: manipulation; 
            -webkit-tap-highlight-color: transparent;
        }
        button:active { background: #2980b9; }
        .score-board {
            color: white;
            font-size: 24px;
            margin: 10px;
            font-family: Arial;
            display: flex;
            gap: 20px;
        }
        .game-over { 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            background: rgba(0, 0, 0, 0.8); 
            color: white; 
            padding: 20px; 
            border-radius: 10px; 
            text-align: center; 
            display: none; 
        }
    </style>
</head>
<body>
    <div class="score-board">
        <div>Score: <span id="currentScore">0</span></div>
        <div>Best: <span id="bestScore">0</span></div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div class="controls">
        <button id="leftBtn">‚Üê</button>
        <button id="soundBtn">üîä Sound</button>
        <button id="rightBtn">‚Üí</button>
    </div>
    <div class="game-over" id="gameOver">
        <h2>Game Over!</h2>
        <button onclick="restartGame()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
    </div>

    <script>
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è localStorage –¥–ª—è —Ä–µ–∫–æ—Ä–¥–æ–≤
        let bestScore = localStorage.getItem('bestScore') || 0;
        document.getElementById('bestScore').textContent = bestScore;

        const CONFIG = {
            ROAD: {
                widthRatio: 0.8,
                lanes: 4,
                colors: {
                    road: '#7f8c8d',
                    marker: '#ffffff',
                    shoulder: '#34495e'
                }
            },
            PLAYER: {
                width: 30,
                height: 50,
                speed: 7,
                color: '#e74c3c',
                lane: 1
            },
            ENEMIES: {
                types: [
                    {
                        width: 30,
                        height: 50,
                        speed: 4,
                        color: '#2ecc71'
                    }
                ],
                spawnRate: 100
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let enemies = [];
        let score = 0;
        let gameLoop;
        let isGameOver = false;
        let soundEnabled = true;

        const ROAD = {
            left: () => canvas.width * (1 - CONFIG.ROAD.widthRatio) / 2,
            right: () => ROAD.left() + canvas.width * CONFIG.ROAD.widthRatio,
            laneWidth: () => (ROAD.right() - ROAD.left()) / CONFIG.ROAD.lanes,
            getLaneCenter: lane => ROAD.left() + (lane + 0.5) * ROAD.laneWidth()
        };

        const player = {
            x: 0,
            y: canvas.height - 80,
            lane: CONFIG.PLAYER.lane,
            width: CONFIG.PLAYER.width,
            height: CONFIG.PLAYER.height,
            color: CONFIG.PLAYER.color,
            updatePosition() {
                this.x = ROAD.getLaneCenter(this.lane) - this.width/2;
            }
        };

        // –ó–∞–ø—Ä–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é
        document.addEventListener('contextmenu', e => e.preventDefault());

        function resizeCanvas() {
            canvas.width = Math.min(window.innerWidth - 20, 400);
            canvas.height = canvas.width * 0.8;
            player.y = canvas.height - 80;
            player.updatePosition();
            enemies = [];
        }

        function addEventListeners() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const soundBtn = document.getElementById('soundBtn');
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
            const handleTouch = e => {
                e.preventDefault();
                if(e.cancelable) e.preventDefault();
            };

            leftBtn.addEventListener('touchstart', e => {
                handleTouch(e);
                movePlayer(-1);
            });
            
            rightBtn.addEventListener('touchstart', e => {
                handleTouch(e);
                movePlayer(1);
            });

            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
            document.addEventListener('keydown', e => {
                if(e.key === 'ArrowLeft') movePlayer(-1);
                if(e.key === 'ArrowRight') movePlayer(1);
            });

            soundBtn.addEventListener('click', toggleSound);
        }

        function movePlayer(direction) {
            player.lane = Math.max(0, Math.min(CONFIG.ROAD.lanes - 1, player.lane + direction));
            player.updatePosition();
        }

        function updateBestScore() {
            if(score > bestScore) {
                bestScore = score;
                localStorage.setItem('bestScore', bestScore);
                document.getElementById('bestScore').textContent = bestScore;
            }
        }

        function createEnemy() {
            const lane = Math.floor(Math.random() * CONFIG.ROAD.lanes);
            enemies.push({
                x: ROAD.getLaneCenter(lane) - CONFIG.ENEMIES.types[0].width/2,
                y: -CONFIG.ENEMIES.types[0].height,
                ...CONFIG.ENEMIES.types[0]
            });
        }

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function updateGame() {
            if(isGameOver) return;

            enemies.forEach(enemy => {
                enemy.y += enemy.speed;
                if(checkCollision(player, enemy)) gameOver();
            });

            enemies = enemies.filter(enemy => {
                if(enemy.y > canvas.height) {
                    score += 10;
                    document.getElementById('currentScore').textContent = score;
                    return false;
                }
                return true;
            });

            if(Math.random() * CONFIG.ENEMIES.spawnRate < 1) {
                createEnemy();
            }
        }

        function drawRoad() {
            ctx.fillStyle = CONFIG.ROAD.colors.road;
            ctx.fillRect(ROAD.left(), 0, ROAD.right() - ROAD.left(), canvas.height);

            ctx.strokeStyle = CONFIG.ROAD.colors.marker;
            ctx.setLineDash([20, 15]);
            for(let i = 1; i < CONFIG.ROAD.lanes; i++) {
                ctx.beginPath();
                ctx.moveTo(ROAD.left() + i * ROAD.laneWidth(), 0);
                ctx.lineTo(ROAD.left() + i * ROAD.laneWidth(), canvas.height);
                ctx.stroke();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawRoad();
            
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            
            enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
            });
        }

        function gameOver() {
            isGameOver = true;
            updateBestScore();
            document.getElementById('gameOver').style.display = 'block';
            cancelAnimationFrame(gameLoop);
        }

        function restartGame() {
            player.lane = CONFIG.PLAYER.lane;
            player.updatePosition();
            enemies = [];
            score = 0;
            document.getElementById('currentScore').textContent = '0';
            isGameOver = false;
            document.getElementById('gameOver').style.display = 'none';
            gameLoop = requestAnimationFrame(game);
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundBtn').textContent = 
                `üîä Sound: ${soundEnabled ? 'ON' : 'OFF'}`;
        }

        function game() {
            updateGame();
            draw();
            gameLoop = requestAnimationFrame(game);
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        addEventListeners();
        game();
    </script>
</body>
</html>
